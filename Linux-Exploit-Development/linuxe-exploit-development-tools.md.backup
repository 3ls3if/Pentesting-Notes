# Binary, Dynamic Information - Gathering Tools

## Lab 3.1: Hello.c

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main() {
	char *ghh = malloc(30);
	strncpy(ghh, "Gray Hat Hacking", 16);
	printf("%s - ", ghh);
	free(ghh);
	puts("6th Edition");
	return 0;
}
```

```
gcc hello.c -o hello

./hello
```


## Lab 3.2: ldd

The ldd tool displays the shared libraries loaded by
programs at runtime.

These libraries have the suﬃx .so
(shared object) and consist of individual ﬁles that contain a
list of functions.

Attack opportunities range from ﬁnding
weak ﬁle permissions and using rpath to replace a shared
library with an evil one, to being able to leak an address of a
loaded library, and even abusing its interesting gadgets to
achieve execution ﬂow control with ROP/JOP code-reuse
attack techniques.

```
ldd /bin/ls
```



## Lab 3.3: objdump

We can use objdump as a command-line disassembler and
also to get important information about executable ﬁles and
objects.


### Getting the Global Offset Table (GOT) and Procedure Linkage Table (PLT)

With the -R option, you can display the list of functions in
the GOT:

```
objdump -R ./hello
```

Now let’s use objdump to locate the address that will be
called in the PLT to get to the puts() function:

```
objdump -M intel -d -j .plt ./hello | grep 4020
```

- -M intel tells objdump to use Intel syntax mode instead of the default (AT&T).
- -d is short for --disassemble.
- -j .plt speciﬁes the section we want to display (PLT).

Now we will use -j .text to ﬁnd the call to puts in the
program we are analyzing:

```
objdump -M intel -d -j .text ./hello | grep 1040
```


### Finding References to Constant Strings

#### Step 1: Using strings

```
strings -tx hello | grep "6th"
```

- -tx (-t is for radix, x is for hexadecimal) prints the oﬀset within the ﬁle at the beginning of each string.


#### Step 2: Using objdump

```
objdump -M intel -d ./hello | grep -C1 200a
```


## Lab 3.4: strace

The strace command-line utility is useful when we need to
trace system calls and signals.

It uses the ptrace system call to inspect and manipulate the target program, and besides allowing us to better understand the program’s behavior.

### Install strace
```
sudo apt install strace
```

### Run strace
```
strace ./hello
```

### Trace/Filter Specific System Call
```
strace -e trace=write ./hello
```

### Program behavior if write function is not implemented
```
strace -e trace=write -e fault=write ./hello
```

### Inject Error EAGAIN
```
strace -e fault=write:error=EAGAIN ./hello
```

### Injecting Delays

Let’s inject a delay of 1 second
before the read function executes (delay_enter) and a
delay 1 second after the write function executes
(delay_exit). By default, the expected time precision is
microseconds:

```
strace -e inject=read:delay_enter=1000000 -e inject=write:delay_exit=1000000 ./hello
```

### Reference

[Modern strace](https://events19.linuxfoundation.org/wp-content/uploads/2017/12/Modern-Strace-Dmitry-Levin-BaseALT.pdf)
