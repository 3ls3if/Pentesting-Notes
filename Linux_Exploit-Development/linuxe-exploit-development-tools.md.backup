# Binary, Dynamic Information - Gathering Tools

## Lab 3.1: Hello.c

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main() {
	char *ghh = malloc(30);
	strncpy(ghh, "Gray Hat Hacking", 16);
	printf("%s - ", ghh);
	free(ghh);
	puts("6th Edition");
	return 0;
}
```

```
gcc hello.c -o hello

./hello
```


## Lab 3.2: ldd

The ldd tool displays the shared libraries loaded by
programs at runtime.

These libraries have the suﬃx .so
(shared object) and consist of individual ﬁles that contain a
list of functions.

Attack opportunities range from ﬁnding
weak ﬁle permissions and using rpath to replace a shared
library with an evil one, to being able to leak an address of a
loaded library, and even abusing its interesting gadgets to
achieve execution ﬂow control with ROP/JOP code-reuse
attack techniques.

```
ldd /bin/ls
```



## Lab 3.3: objdump

We can use objdump as a command-line disassembler and
also to get important information about executable ﬁles and
objects.


### Getting the Global Offset Table (GOT) and Procedure Linkage Table (PLT)

With the -R option, you can display the list of functions in
the GOT:

```
objdump -R ./hello
```

Now let’s use objdump to locate the address that will be
called in the PLT to get to the puts() function:

```
objdump -M intel -d -j .plt ./hello | grep 4020
```

- -M intel tells objdump to use Intel syntax mode instead of the default (AT&T).
- -d is short for --disassemble.
- -j .plt speciﬁes the section we want to display (PLT).

Now we will use -j .text to ﬁnd the call to puts in the
program we are analyzing:

```
objdump -M intel -d -j .text ./hello | grep 1040
```


### Finding References to Constant Strings

#### Step 1: Using strings

```
strings -tx hello | grep "6th"
```

- -tx (-t is for radix, x is for hexadecimal) prints the oﬀset within the ﬁle at the beginning of each string.


#### Step 2: Using objdump

```
objdump -M intel -d ./hello | grep -C1 200a
```


## Lab 3.4: strace

The strace command-line utility is useful when we need to
trace system calls and signals.

It uses the ptrace system call to inspect and manipulate the target program, and besides allowing us to better understand the program’s behavior.

### Install strace
```
sudo apt install strace
```

### Run strace
```
strace ./hello
```

### Trace/Filter Specific System Call
```
strace -e trace=write ./hello
```

### Program behavior if write function is not implemented
```
strace -e trace=write -e fault=write ./hello
```

### Inject Error EAGAIN
```
strace -e fault=write:error=EAGAIN ./hello
```

### Injecting Delays

Let’s inject a delay of 1 second
before the read function executes (delay_enter) and a
delay 1 second after the write function executes
(delay_exit). By default, the expected time precision is
microseconds:

```
strace -e inject=read:delay_enter=1000000 -e inject=write:delay_exit=1000000 ./hello
```

### Reference

[Modern strace](https://events19.linuxfoundation.org/wp-content/uploads/2017/12/Modern-Strace-Dmitry-Levin-BaseALT.pdf)

## Lab 3.5: ltrace

The main purpose of the ltrace utility is to trace calls to shared libraries and their responses, but it can also be used to trace system calls.

### Install ltrace
```
sudo apt install ltrace
```

### Run ltrace
```
ltrace ./hello
```

### Display System Calls
```
ltrace -S ./hello
```


## Lab 3.6: checksec

The checksec shell script parses a program’s ELF header to determine which compile-time mitigation technologies are being used, such as RELRO, NX, Stack Canaries, ASLR, and PIE.

### Install checksec
```
sudo apt install checksec
```

```
git clone https://github.com/slimm609/checksec.sh
```

### Run checksec
```
./checksec --file=./hello
```

### Compile hello.c with security mitigations

```
gcc hello.c -Wl,-z,relro,-z,now -O2 -D_FORTIFY_SOURCE=2 -s -fstack-protector-all -o hello-stronger
```

### Run hello-stronger
```
./hello-stronger
```

## Lab 3.7: libc-database

Sometimes you manage to ﬁnd and exploit an information
leak vulnerability, but it is impossible to calculate the oﬀset
to the libc base or other functions unless you know the libc
version being used on the remote host. The libc-database
downloads a list of conﬁgured libc versions, extracts the
symbol oﬀsets, and allows you to query the function name
and leaked address in order to identify the libc version being
used.


### Clone libc-database
```
git clone https://github.com/niklasb/libc-database.git
```

### Download libc version for Kali
```
./get kali
```

### Find libc versions
#### Get puts offset
```
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep puts
```

#### Find script
```
./find puts 765f0
```

#### Online Database

[Online Database](https://libc.blukat.me)

